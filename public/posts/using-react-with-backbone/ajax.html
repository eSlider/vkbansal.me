<p><a href="http://backbonejs.org/">Backbone</a> is a very popular and minimal MVC framework for javascript by <a href="https://github.com/jashkenas">Jeremy Ashkenas</a>. It gives a web application a nice structure and helps in seperation of concerns with <em>Models, Collections and Views</em>. But Backbone Views are very minimal and requires a lot of code to setup. This is where <a href="http://facebook.github.io/react/">React</a> steps in. It's a javascript library for building user interfaces by Facebook and people use React as the V in MVC as their website states. While researching for ways to use them together I came across many different solutions but none of them were satisfactory for me until I came across an answer by <a href="https://twitter.com/dan_abramov">Dan Abramov</a> on <a href="http://stackoverflow.com/questions/21709905/can-i-avoid-forceupdate-when-using-react-with-backbone/21709906#21709906">stackoverflow</a>. I found it very helpful and wanted to share this.</p>
<p>###The Mixin
Dan made a simple mixin which uses  neither <code>setProps</code> nor <code>forceUpdate</code> which is what I was exactly looking for.</p>
<pre><code class="language-javascript">var BackboneStateMixin = {
    getInitialState: function () {
        return this.getBackboneState(this.props);
    },

    componentDidMount: function () {
        if (!_.isFunction(this.getBackboneState)) {
            throw new Error('You must provide getBackboneState(props).');
        }

        this._bindBackboneEvents(this.props);
    },

    componentWillReceiveProps: function (newProps) {
        this._unbindBackboneEvents();
        this._bindBackboneEvents(newProps);
    },

    componentWillUnmount: function () {
        this._unbindBackboneEvents();
    },

    _updateBackboneState: function () {
        var state = this.getBackboneState(this.props);
        this.setState(state);
    },

    _bindBackboneEvents: function (props) {
        if (!_.isFunction(this.watchBackboneProps)) {
            return;
        }

        if (this._backboneListener) {
            throw new Error('Listener already exists.');
        }

        if (!props) {
            throw new Error('Passed props are empty');
        }

        var listener = _.extend({}, Backbone.Events),
            listenTo = _.partial(listener.listenTo.bind(listener), _, _, this._updateBackboneState);

        this.watchBackboneProps(props, listenTo);
        this._backboneListener = listener;
    },

    _unbindBackboneEvents: function () {
        if (!_.isFunction(this.watchBackboneProps)) {
            return;
        }

        if (!this._backboneListener) {
            throw new Error('Listener does not exist.');
        }

        this._backboneListener.stopListening();
        delete this._backboneListener;
    }
};
</code></pre>
<p>The idea behind this mixin is that <em>Backbone Models\Collections</em> are set as <code>props</code> and their <code>toJSON</code>  value is automatically put by mixin into <code>state</code>. One needs to override <code>getBackboneState(props)</code> for this to work, and optionally <code>watchBackboneProps</code> to tell the mixin when to call <code>setState</code> with fresh values.</p>
<p>###Usage Example
The above mixin can be used with any <em>React components</em> as follows without having to worry about stale values in <em>Backbone Model\Collection</em></p>
<pre><code class="language-javascript">var MyComponent = React.createClass({
    mixins: [BackboneStateMixin],
    getBackboneState: function(props) {
        return {
            model: props.model.toJSON(),
            collection: props.collection.toJSON()
        }
    },
    watchBackboneProps: function(props, listenTo) {
        listenTo(props.model, 'change:someValue');
        listenTo(props.collection, 'change reset add remove');
    },
    render: function() {
        //Use JSON values from this.state.model 
        //or this.state.collection
    }
});
</code></pre>
<p>###Conclusion
I found this very helpful and hope you too can benefit from it.</p>
